import{J as T,H as I,a3 as v,aq as x,ay as B,aj as E}from"./main-DTRXeM_0.js";import{a as A}from"./index-BpweNmNx.js";import"./wScoge-CcoIV1Ln.js";async function _(e){const t=await e({method:"eth_blockNumber"});return T(t)}const L=5e3,P=1e3,g=500,F=2,k=10;function G(e){for(;e.length<k;)e.unshift(P);return e.reduce((n,o)=>n+o,0)/e.length}function D(e,t,n,o){let a=[],r=[],c=!1,s,i;const d=I({client:e,chain:t});async function l(){if(!c)return;try{const u=await _(d);if(!s||u>s){let w=[];if(s)for(let f=s+1n;f<=u;f++)w.push(BigInt(f));else w=[u];s=u;const y=new Date().getTime();if(i){const f=(y-i)/w.length;r.push(f),r=r.slice(-k)}i=y;for(const f of w)for(const N of a)N(f)}}catch(u){o?o(u):console.error(`[watchBlockNumber]: Failed to poll for latest block number: ${u}`)}const m=G(r),h=Math.max(g,Math.min(L,Math.max(g,m)));await H(h/(n??F)),l()}return function(h,u){return a.push(h),c||(s=u,c=!0,l()),function(){a=a.filter(y=>y!==h),a.length===0&&(s=void 0,i=void 0,c=!1)}}}function H(e){return new Promise(t=>setTimeout(t,e))}const p=new Map;function U(e){const{client:t,chain:n,onNewBlockNumber:o,overPollRatio:a,latestBlockNumber:r,onError:c}=e,s=n.id;let i=p.get(s);return i||(i=D(t,n,a,c),p.set(s,i)),i(o,r)}function q(e,{args:t,eventName:n}={}){return{...e,blockHash:e.blockHash?e.blockHash:null,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,logIndex:e.logIndex?Number(e.logIndex):null,transactionHash:e.transactionHash?e.transactionHash:null,transactionIndex:e.transactionIndex?Number(e.transactionIndex):null,...n?{args:t,eventName:n}:{}}}const C={"0x0":"reverted","0x1":"success"};function M(e){const t={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs?e.logs.map(n=>q(n)):null,to:e.to?e.to:null,transactionIndex:e.transactionIndex?v(e.transactionIndex):null,status:e.status?C[e.status]:null,type:e.type?A[e.type]||e.type:null};return e.blobGasPrice&&(t.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(t.blobGasUsed=BigInt(e.blobGasUsed)),t}async function $(e,t){const n=await e({method:"eth_getTransactionReceipt",params:[t.hash]});if(!n)throw new Error("Transaction receipt not found.");return M(n)}const O=30,b=new Map;function S(e){const{transactionHash:t,chain:n,client:o}=e,r=`${n.id}:tx_${t}`,c=e.maxBlocksWaitTime??O;if(b.has(r))return b.get(r);const s=new Promise((i,d)=>{t||d(new Error("Transaction has no transactionHash to wait for, did you execute it?"));const l=I({client:o,chain:n});let m=-1;const h=U({client:o,chain:n,onNewBlockNumber:async()=>{if(m++,m>=c){h(),d(new Error(`Transaction not found after ${c} blocks`));return}try{const u=await $(l,{hash:t});h(),i(u)}catch{}}})}).finally(()=>{b.delete(r)});return b.set(r,s),s}async function W({account:e,serializableTransaction:t,transaction:n,gasless:o}){const a=B({address:o.relayerForwarderAddress,chain:n.chain,client:n.client}),r=await E({contract:a,method:"function getNonce(address) view returns (uint256)",params:[e.address]}),[c,s]=await(async()=>{if(!t.to)throw new Error("engine transactions must have a 'to' address");if(!t.gas)throw new Error("engine transactions must have a 'gas' value");if(!t.data)throw new Error("engine transactions must have a 'data' value");if(o.experimentalChainlessSupport){const l={from:e.address,to:t.to,value:0n,gas:t.gas,nonce:r,data:t.data,chainid:BigInt(n.chain.id)};return[await e.signTypedData({domain:{name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:a.address},message:l,primaryType:"ForwardRequest",types:{ForwardRequest:Y}}),l]}const d={from:e.address,to:t.to,value:0n,gas:t.gas,nonce:r,data:t.data};return[await e.signTypedData({domain:{name:o.domainName??"GSNv2 Forwarder",version:o.domainVersion??"0.0.1",chainId:n.chain.id,verifyingContract:a.address},message:d,primaryType:"ForwardRequest",types:{ForwardRequest:j}}),d]})();return{message:s,signature:c,messageType:"forward"}}const j=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],Y=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function Z(e){const{message:t,messageType:n,signature:o}=await W(e),a=await fetch(e.gasless.relayerUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:x({request:t,type:n,signature:o,forwarderAddress:e.gasless.relayerForwarderAddress})});if(!a.ok)throw new Error(`Failed to send transaction: ${await a.text()}`);const r=await a.json();if(!r.result)throw new Error(`Relay transaction failed: ${r.message}`);const c=r.result.queueId,s=6e4,i=1e3,d=Date.now()+s;for(;Date.now()<d;){const l=await J({options:e,queueId:c});if(l)return{transactionHash:l.transactionHash,chain:e.transaction.chain,client:e.transaction.client};await new Promise(m=>setTimeout(m,i))}throw new Error(`Failed to find relayed transaction after ${s}ms`)}async function J(e){const{options:t,queueId:n}=e,o=t.gasless.relayerUrl.split("/relayer/")[0],a=await fetch(`${o}/transaction/status/${n}`,{method:"GET"}),r=await a.json();if(!a.ok)return null;const c=r.result;if(!c)return null;switch(c.status){case"errored":throw new Error(`Transaction errored with reason: ${c.errorMessage}`);case"cancelled":throw new Error("Transaction execution cancelled.");case"mined":return await S({client:t.transaction.client,chain:t.transaction.chain,transactionHash:c.transactionHash});default:return null}}export{Y as ChainAwareForwardRequest,j as ForwardRequest,W as prepareEngineTransaction,Z as relayEngineTransaction};
