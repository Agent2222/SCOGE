import{bf as l}from"./main-BFKE91JP.js";import"./wScoge-BthgsBuw.js";var c=null;class m{constructor(e,t){this.mapEvents=t,this.direction=null,this.playerOnline=!1,this.ably=l(),this.rooms=[],this.uniPlayer=e.uniPlayer,this.currentRoom=null,this.channels={},this.initPlayer()}async initPlayer(e){await this.connect().catch(t=>{console.error("Error connecting to Ably:",t)}),this.playerOnline=!0,console.log(`Player ${this.uniPlayer} added to the game`),this.joinRoom(1,this.uniPlayer),console.log("Channel",this.channels[1]),c=this.channels[1],document.getElementById("compEmoter").setAttribute("active","true")}createShadowPlayer(e){var t=document.querySelector("#uniPlayers"),n=t.getContext("2d"),s=null,o=null;s=Number(String(e.x).replace("px","")),o=Number(String(e.y).replace("px","")),n.beginPath(),n.rect(s,o,18,18),n.lineWidth=2,n.strokeStyle="#dadcd57f",n.stroke(),n.closePath()}async connect(){return new Promise((e,t)=>{this.ably.connection.once("connected",()=>{console.log("Connected to Ably realtime service!"),this.playerOnline=!0,e()}),this.ably.connection.once("failed",n=>{console.error("Connection to Ably failed:",n),t(n)})})}disconnect(){this.currentRoom&&this.leaveRoom(this.currentRoom.roomId),Object.keys(this.channels).forEach(e=>{this.channels[e]&&this.channels[e].detach()}),this.ably&&this.ably.connection&&(this.ably.connection.close(),this.playerOnline=!1,console.log("Disconnected from Ably"))}createRoom(e,t,n=!0){const s=this.rooms.length>0?Math.max(...this.rooms.map(i=>i.roomId))+1:1,o={roomId:s,roomType:t,roomName:e,public:n,messages:[],players:[],createdAt:new Date().toISOString()};this.rooms.push(o);const r=`room-${s}`;return this.channels[s]=this.ably.channels.get(r),console.log(`Room joined: ${e} (ID: ${s})`),this.joinRoom(s,this.uniPlayer),o}destroyRoom(e){const t=this.rooms.findIndex(s=>s.roomId===e);return t===-1?(console.error(`Room with ID ${e} not found`),!1):(this.rooms[t].players.forEach(s=>{this.removePlayerFromRoom(s.id,e)}),this.channels[e]&&(this.channels[e].detach(s=>{s?console.error(`Error detaching from room ${e} channel:`,s):console.log(`Successfully detached from room ${e} channel`)}),delete this.channels[e]),this.rooms.splice(t,1),console.log(`Room ${e} destroyed`),!0)}async joinRoom(e,t){const n=this.getRoom(e);if(!n)return console.error(`Room with ID ${e} not found`),this.createRoom("TAOS City","City",!0),!1;if(n.players.some(r=>r.id===t.id))return console.log(`Player ${t.id} is already in room ${e}`),!0;n.players.push(t);const o=`room-${e}`;return this.channels[e]=this.ably.channels.get(o),console.log("Room",n,"channel",this.channels[e]),this.subscribeToPlayerPresence(e,{}),this.channels[e].presence.enter(this.uniPlayer,r=>{r&&console.error(`Error entering presence for room ${e}:`,r)}),this.currentRoom=n,console.log(`Player ${t.id} joined room ${e}`),!0}leaveRoom(e,t){return this.getRoom(e)?(!t&&this.uniPlayer&&(t=this.uniPlayer.id),t?(this.removePlayerFromRoom(t,e),this.channels[e]&&(this.channels[e].presence.leave({playerId:t},s=>{s&&console.error(`Error leaving presence for room ${e}:`,s)}),this.channels[e].publish("player-leave",{playerId:t,timestamp:new Date().toISOString()},s=>{s&&console.error("Error publishing leave event:",s)}),this.channels[e].unsubscribe(),this.channels[e].detach(),delete this.channels[e]),this.currentRoom&&this.currentRoom.roomId===e&&(this.currentRoom=null),console.log(`Player ${t} left room ${e}`),!0):(console.error("No player ID provided"),!1)):(console.error(`Room with ID ${e} not found`),!1)}updatePlayerInRoom(e,t){const n=this.getRoom(t);if(!n)return!1;const s=n.players.findIndex(o=>o.playerId===e.playerId);return s===-1?(n.players.push(e),console.log(`Player ${e.id} added to room ${t}`)):n.players[s]={...n.players[s],...e},this.mapEvents.clearPlayerShadow(this.direction,Number(this.uniPlayer.previousX),Number(this.uniPlayer.previousY)),this.getPlayersInRoom(1),!0}removePlayerFromRoom(e,t){const n=this.getRoom(t);if(!n)return console.error(`Room with ID ${t} not found, creating new room`),!1;const s=n.players.findIndex(o=>o.playerId===e);return s===-1?(console.warn(`Player ${e} not found in room ${t}`),!1):(n.players.splice(s,1),!0)}getRoom(e){return this.rooms.find(t=>t.roomId===e)||null}getAllPlayers(){const e=[];return this.rooms.forEach(t=>{t.players.forEach(n=>{e.some(s=>s.id===n.id)||e.push(n)})}),e}getPlayersInRoom(e){const t=this.getRoom(e);if(!t)return console.error(`Room with ID ${e} not found`),[];t.players.forEach(n=>{this.createShadowPlayer(n),n.emote!==null&&this.drawEmoteAtCoords(n.x,n.y,n.emote)})}testShat(){}sendMessage(e,t){var o;const n=this.getRoom(e);if(!n)return console.error(`Room with ID ${e} not found`),!1;if(!this.channels[e])return console.error(`Not connected to room ${e}`),!1;const s={id:new Date().getTime(),sender:this.uniPlayer?this.uniPlayer.id:"system",senderName:((o=this.uniPlayer)==null?void 0:o.name)||"System",content:t,timestamp:new Date().toISOString()};return this.channels[e].publish("message",s,r=>{if(r)return console.error("Error publishing message:",r),!1;n.messages&&n.messages.push(s)}),!0}async getMessageHistory(e,t=100){const n=this.getRoom(e);if(!n)return console.error(`Room with ID ${e} not found`),[];if(!this.channels[e])return console.error(`Not connected to room ${e}`),n.messages||[];try{const o=(await this.channels[e].history({limit:t})).items.map(r=>r.data).reverse();if(n.messages){const r=new Set(n.messages.map(a=>a.id)),i=o.filter(a=>!r.has(a.id));n.messages=[...n.messages,...i]}else n.messages=o;return n.messages}catch(s){return console.error("Error getting message history:",s),n.messages||[]}}getMessages(e){const t=this.getRoom(e);return!t||!t.messages?[]:t.messages}async getOnlinePlayers(e){if(!this.getRoom(e))return console.error(`Room with ID ${e} not found`),[];if(!this.channels[e])return console.error(`Not connected to room ${e}`),[];try{const n=await this.channels[e].presence.get();console.log("Presence Data",n);const s=n.map(o=>o);return console.log(`Online players in room ${e}:`,s),s}catch(n){return console.error("Error getting online players:",n),[]}}subscribeToPlayerPresence(e,t={}){return this.getRoom(e),this.channels[e].presence.subscribe("enter",async n=>{console.log(`Player ${n} entered the room`),JSON.parse(JSON.stringify(n.data))}),this.channels[e].presence.subscribe("leave",n=>{console.log(`Player ${n.data.data.playerId} left the room`),this.removePlayerFromRoom(n.data.data.playerId,e),t.onPlayerLeave&&t.onPlayerLeave(n.data)}),this.channels[e].presence.subscribe("update",n=>{let s=JSON.parse(JSON.stringify(n.data));this.updatePlayerInRoom(s.data,e)}),!0}unsubscribeFromPlayerPresence(e){return this.channels[e]?(this.channels[e].presence.unsubscribe(),!0):(console.error(`Not connected to room ${e}`),!1)}isPlayerInRoom(e,t){const n=this.getRoom(t);return n?n.players.some(s=>s.id===e):!1}subscribeToEvent(e,t,n){return this.channels[e]?(this.channels[e].subscribe(t,s=>{n(s.data,s)}),!0):(console.error(`Not connected to room ${e}`),!1)}publishEvent(e,t,n){var s;return this.channels[e]?(this.channels[e].publish(t,{...n,senderId:((s=this.uniPlayer)==null?void 0:s.id)||"system",timestamp:new Date().toISOString()},o=>{if(o)return console.error(`Error publishing ${t} event:`,o),!1}),!0):(console.error(`Not connected to room ${e}`),!1)}setupConnectionStateHandling(){this.ably.connection.on("connected",()=>{console.log("Connected to Ably!"),this.playerOnline=!0,this.currentRoom&&this.uniPlayer&&this.joinRoom(this.currentRoom.roomId,this.uniPlayer)}),this.ably.connection.on("disconnected",()=>{console.log("Disconnected from Ably"),this.playerOnline=!1}),this.ably.connection.on("failed",e=>{console.error("Connection to Ably failed:",e),this.playerOnline=!1}),this.ably.connection.on("suspended",()=>{console.warn("Connection to Ably suspended"),this.playerOnline=!1})}getConnectionState(){return!this.ably||!this.ably.connection?"not_initialized":this.ably.connection.state}static generatePlayerId(){return`player-${Date.now()}-${Math.random().toString(36).substr(2,9)}`}async drawEmoteAtCoords(e,t,n){let o=document.querySelector("#uniPlayers").getContext("2d");new Image,o.beginPath(),o.arc(e+20,t+20,14,0,Math.PI*2),o.fillStyle="rgba(0, 0, 0, 0.5)",o.fill(),o.closePath(),o.font="18px Arial",o.fillText(n,e+9,t+27)}}export{m as Multiplayer_Ably,c as channel};
